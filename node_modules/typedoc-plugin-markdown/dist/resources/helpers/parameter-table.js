"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parameterTable = void 0;
const typedoc_1 = require("typedoc");
const comment_1 = require("./comment");
const escape_1 = require("./escape");
const property_table_1 = require("./property-table");
const strip_line_breaks_1 = require("./strip-line-breaks");
const type_1 = require("./type");
function parameterTable(kind) {
    const parameters = this;
    const hasNamedParams = parameters.some((parameter) => parameter.name === '__namedParameters');
    if (hasNamedParams) {
        return list(parameters);
    }
    return table(parameters, kind);
}
exports.parameterTable = parameterTable;
function list(parameters) {
    const output = [];
    parameters.forEach((parameter) => {
        var _a;
        output.push(`â€¢ **${parameter.name}**: ${type_1.type.call(parameter.type, true)}`);
        if (parameter.comment) {
            output.push(comment_1.comment.call(parameter.comment));
        }
        if (((_a = parameter.type) === null || _a === void 0 ? void 0 : _a.declaration) && parameter.type.declaration.children) {
            output.push(property_table_1.propertyTable.call(parameter.type.declaration.children));
        }
    });
    return output.join('\n\n');
}
function table(parameters, kind) {
    const showDefaults = hasDefaultValues(kind, parameters);
    const showTypes = kind === 'parameters' ? true : hasTypes(parameters);
    const comments = parameters.map((param) => (param.comment && !!param.comment.text) ||
        (param.comment && !!param.comment.shortText));
    const hasComments = !comments.every((value) => !value);
    const headers = ['Name'];
    if (showTypes) {
        headers.push('Type');
    }
    if (showDefaults) {
        headers.push(kind === 'parameters' ? 'Default value' : 'Default');
    }
    if (hasComments) {
        headers.push('Description');
    }
    const rows = parameters.map((parameter) => {
        const row = [];
        row.push(`\`${parameter.flags.isRest ? '...' : ''}${parameter.name}${parameter.flags.isOptional ? '?' : ''}\``);
        if (showTypes) {
            row.push(parameter.type ? type_1.type.call(parameter.type) : '-');
        }
        if (showDefaults) {
            row.push(getDefaultValue(parameter));
        }
        if (hasComments) {
            if (parameter.comment) {
                row.push(strip_line_breaks_1.stripLineBreaks(comment_1.comment.call(parameter.comment)).replace(/\|/g, '\\|'));
            }
            else {
                row.push('-');
            }
        }
        return `${row.join(' | ')} |\n`;
    });
    const output = `\n${headers.join(' | ')} |\n${headers
        .map(() => '------')
        .join(' | ')} |\n${rows.join('')}`;
    return output;
}
function getDefaultValue(parameter) {
    if (parameter instanceof typedoc_1.TypeParameterReflection) {
        return parameter.default ? type_1.type.call(parameter.default) : '-';
    }
    return parameter.defaultValue ? escape_1.escape(parameter.defaultValue) : '-';
}
function hasDefaultValues(kind, parameters) {
    const defaultValues = kind === 'parameters'
        ? parameters.map((param) => !!param.defaultValue)
        : parameters.map((param) => !!param.default);
    return !defaultValues.every((value) => !value);
}
function hasTypes(parameters) {
    const types = parameters.map((param) => !!param.type);
    return !types.every((value) => !value);
}
